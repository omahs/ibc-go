"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[467],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,g=p["".concat(s,".").concat(h)]||p[h]||u[h]||a;return n?i.createElement(g,o(o({ref:t},d),{},{components:n})):i.createElement(g,o({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},86251:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(87462),r=(n(67294),n(3905));const a={},o="ADR 27: Add support for Wasm based light client",l={unversionedId:"adr-027-ibc-wasm",id:"adr-027-ibc-wasm",title:"ADR 27: Add support for Wasm based light client",description:"Changelog",source:"@site/architecture/adr-027-ibc-wasm.md",sourceDirName:".",slug:"/adr-027-ibc-wasm",permalink:"/architecture/adr-027-ibc-wasm",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"ADR 026: IBC Client Recovery Mechanisms",permalink:"/architecture/adr-026-ibc-client-recovery-mechanisms"}},s={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"How light client proxy works?",id:"how-light-client-proxy-works",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"adr-27-add-support-for-wasm-based-light-client"},"ADR 27: Add support for Wasm based light client"),(0,r.kt)("h2",{id:"changelog"},"Changelog"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"26/11/2020: Initial Draft")),(0,r.kt)("h2",{id:"status"},"Status"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Draft, needs updates")),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"In the Cosmos SDK light clients are current hardcoded in Go. This makes upgrading existing IBC light clients or adding\nsupport for new light client a multi step process involving on-chain governance which is time-consuming."),(0,r.kt)("p",null,"To remedy this, we are proposing a WASM VM to host light client bytecode, which allows easier upgrading of\nexisting IBC light clients as well as adding support for new IBC light clients without requiring a code release and corresponding\nhard-fork event."),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,"Currently in the SDK, light clients are defined as part of the codebase and are implemented as submodules under\n",(0,r.kt)("inlineCode",{parentName:"p"},"ibc-go/core/modules/light-clients/"),"."),(0,r.kt)("p",null,"Adding support for new light client or update an existing light client in the event of security\nissue or consensus update is multi-step process which is both time consuming and error prone:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"To add support for new light client or update an existing light client in the\nevent of security issue or consensus update, we need to modify the codebase and integrate it in numerous places.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Governance voting: Adding new light client implementations require governance support and is expensive: This is\nnot ideal as chain governance is gatekeeper for new light client implementations getting added. If a small community\nwant support for light client X, they may not be able to convince governance to support it.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Validator upgrade: After governance voting succeeds, validators need to upgrade their nodes in order to enable new\nIBC light client implementation."))),(0,r.kt)("p",null,"Another problem stemming from the above process is that if a chain wants to upgrade its own consensus, it will need to convince every chain\nor hub connected to it to upgrade its light client in order to stay connected. Due to time consuming process required\nto upgrade light client, a chain with lots of connections needs to be disconnected for quite some time after upgrading\nits consensus, which can be very expensive in terms of time and effort."),(0,r.kt)("p",null,"We are proposing simplifying this workflow by integrating a WASM light client module which makes adding support for\na new light client a simple transaction. The light client bytecode, written in Wasm-compilable Rust, runs inside a WASM\nVM. The Wasm light client submodule exposes a proxy light client interface that routes incoming messages to the\nappropriate handler function, inside the Wasm VM for execution."),(0,r.kt)("p",null,"With WASM light client module, anybody can add new IBC light client in the form of WASM bytecode (provided they are able to pay the requisite gas fee for the transaction)\nas well as instantiate clients using any created client type. This allows any chain to update its own light client in other chains\nwithout going through steps outlined above."),(0,r.kt)("h2",{id:"decision"},"Decision"),(0,r.kt)("p",null,"We decided to use WASM light client module as a light client proxy which will interface with the actual light client\nuploaded as WASM bytecode. This will require changing client selection method to allow any client if the client type\nhas prefix of ",(0,r.kt)("inlineCode",{parentName:"p"},"wasm/"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// IsAllowedClient checks if the given client type is registered on the allowlist.\nfunc (p Params) IsAllowedClient(clientType string) bool {\n  if p.AreWASMClientsAllowed && isWASMClient(clientType) {\n    return true\n  }\n\n  for _, allowedClient := range p.AllowedClients {\n    if allowedClient == clientType {\n      return true\n    }\n  }\n\n  return false\n}\n")),(0,r.kt)("p",null,"To upload new light client, user need to create a transaction with Wasm byte code which will be\nprocessed by IBC Wasm module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) UploadLightClient (wasmCode: []byte, description: String) {\n  wasmRegistry = getWASMRegistry()\n  id := hex.EncodeToString(sha256.Sum256(wasmCode))\n  assert(!wasmRegistry.Exists(id))\n  assert(wasmRegistry.ValidateAndStoreCode(id, description, wasmCode, false))\n}\n")),(0,r.kt)("p",null,"As name implies, Wasm registry is a registry which stores set of Wasm client code indexed by its hash and allows\nclient code to retrieve latest code uploaded."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ValidateAndStoreCode")," checks if the wasm bytecode uploaded is valid and confirms to VM interface."),(0,r.kt)("h3",{id:"how-light-client-proxy-works"},"How light client proxy works?"),(0,r.kt)("p",null,"The light client proxy behind the scenes will call a cosmwasm smart contract instance with incoming arguments in json\nserialized format with appropriate environment information. Data returned by the smart contract is deserialized and\nreturned to the caller."),(0,r.kt)("p",null,"Consider an example of ",(0,r.kt)("inlineCode",{parentName:"p"},"CheckProposedHeaderAndUpdateState")," function of ",(0,r.kt)("inlineCode",{parentName:"p"},"ClientState")," interface. Incoming arguments are\npackaged inside a payload which is json serialized and passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"callContract")," which calls ",(0,r.kt)("inlineCode",{parentName:"p"},"vm.Execute")," and returns the\narray of bytes returned by the smart contract. This data is deserialized and passed as return argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (c *ClientState) CheckProposedHeaderAndUpdateState(context sdk.Context, marshaler codec.BinaryMarshaler, store sdk.KVStore, header exported.ClientMessage) (exported.ClientState, exported.ConsensusState, error) {\n  // get consensus state corresponding to client state to check if the client is expired\n  consensusState, err := GetConsensusState(store, marshaler, c.LatestHeight)\n  if err != nil {\n    return nil, nil, sdkerrors.Wrapf(\n    err, "could not get consensus state from clientstore at height: %d", c.LatestHeight,\n    )\n  }\n  \n  payload := make(map[string]map[string]interface{})\n  payload[CheckProposedHeaderAndUpdateState] = make(map[string]interface{})\n  inner := payload[CheckProposedHeaderAndUpdateState]\n  inner["me"] = c\n  inner["header"] = header\n  inner["consensus_state"] = consensusState\n\n  encodedData, err := json.Marshal(payload)\n  if err != nil {\n    return nil, nil, sdkerrors.Wrapf(ErrUnableToMarshalPayload, fmt.Sprintf("underlying error: %s", err.Error()))\n  }\n  out, err := callContract(c.CodeId, context, store, encodedData)\n  if err != nil {\n    return nil, nil, sdkerrors.Wrapf(ErrUnableToCall, fmt.Sprintf("underlying error: %s", err.Error()))\n  }\n  output := clientStateCallResponse{}\n  if err := json.Unmarshal(out.Data, &output); err != nil {\n    return nil, nil, sdkerrors.Wrapf(ErrUnableToUnmarshalPayload, fmt.Sprintf("underlying error: %s", err.Error()))\n  }\n  if !output.Result.IsValid {\n    return nil, nil, fmt.Errorf("%s error ocurred while updating client state", output.Result.ErrorMsg)\n  }\n  output.resetImmutables(c)\n  return output.NewClientState, output.NewConsensusState, nil\n}\n')),(0,r.kt)("h2",{id:"consequences"},"Consequences"),(0,r.kt)("h3",{id:"positive"},"Positive"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Adding support for new light client or upgrading existing light client is way easier than before and only requires single transaction."),(0,r.kt)("li",{parentName:"ul"},"Improves maintainability of Cosmos SDK, since no change in codebase is required to support new client or upgrade it.")),(0,r.kt)("h3",{id:"negative"},"Negative"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Light clients need to be written in subset of rust which could compile in Wasm."),(0,r.kt)("li",{parentName:"ul"},"Introspecting light client code is difficult as only compiled bytecode exists in the blockchain.")))}u.isMDXComponent=!0}}]);